#!/usr/bin/env python

################################################################################

__author__ = 'Ribeiro, T.'

################################################################################

import sys
import os
import time
import datetime as dt
import shutil
import re
import yaml
import numpy as np
import ConfigParser
from astropy.table import Table
from sqlalchemy import (or_,and_, desc, asc)
import inspect

from chimera.core.cli import ChimeraCLI, action, ParameterType
from chimera.core.site import datetimeFromJD
from chimera.core.callback import callback
from chimera.core.exceptions import printException, ObjectNotFoundException
from chimera.util.output import blue, green, red
from chimera.util.position import Position


from chimera_manager.core.constants import DEFAULT_PROGRAM_DATABASE, DEFAULT_ROBOBS_DATABASE
from chimera_manager.controllers.scheduler.model import Session as RSession
from chimera_manager.controllers.scheduler.model import (Projects, BlockPar, ObsBlock,
                                                         Targets, ObservingLog,
                                                         Program, AutoFocus, AutoFlat, PointVerify, Point, Expose)
from chimera_manager.controllers.scheduler import algorithms

schedAlgorithms = {}
for name,obj in inspect.getmembers(algorithms):
    if inspect.isclass(obj) and issubclass(obj,algorithms.BaseScheduleAlgorith):
        schedAlgorithms[obj.id()] = obj

actionDict = {'autofocus' : AutoFocus,
              'autoflat' : AutoFlat,
              'pointverify' : PointVerify,
              'point' : Point,
              'expose' : Expose,
              }

################################################################################

class RobObs(ChimeraCLI):
    ############################################################################

    def __init__(self):
        ChimeraCLI.__init__(self, "chimera-robobs",
                            "RobObs controller", 0.0, port=9010)

        '''
        Check manager status and control some actions.
        '''

        self.addHelpGroup("ROBOBS", "RobObs")
        self.addController(name="site",
                           cls="Site",
                           required=True,
                           help="Observing site",
                           helpGroup="OBSERVATORY")

        self.addController(name="telescope",
                           cls="telescope",
                           required=False,
                           help="Telescope to me used. It is used during queue processing for estimating slew time.",
                           helpGroup="TELESCOPE")

        self.addController(name="robobs",
                           cls="RobObs",
                           required=True,
                           help="Robobs controller to be used",
                           helpGroup="ROBOBS")

        self.addHelpGroup("RUN", "Start/Stop/Monitor")
        self.addParameters(dict(name="filename", long="file", short="f",
                                default="",
                                help="Filename with program or block information.",
                                metavar="FILENAME",
                                helpGroup="RUN"))

        self.addHelpGroup("SCHEDULER", "Scheduler")
        self.addParameters(dict(name="PID", long="pid", type='string',
                                help="Project ID flag. Use to select targets from DB.",
                                metavar="PID",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="PIDCONFIG", long="pid-config", type='string',
                                help="A Project (yaml) configuration file. This is read and passed as a dictionary to"
                                     "the project scheduling algorithm.",
                                metavar="PIDCONFIG",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="JDstart", long="jdstart", type=float,
                                help="Julian date of the start of the observations to be scheduled. Override date.",
                                metavar="JDstart",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="JDend", long="jdend", type=float,
                                help="Julian date at the end of the observations to be scheduled. Override date.",
                                metavar="JDend",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="dstart", long="dateStart", type='string',
                                help="Date (yyyy/mm/dd-hh:mm:ss) of the start of the observations to be scheduled.",
                                metavar="dstart",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="dend", long="dateEnd", type='string',
                                help="Date (yyyy/mm/dd-hh:mm:ss.s) of the end of the observations to be scheduled.",
                                metavar="dend",
                                helpGroup="SCHEDULER"))

    ############################################################################

    @action(long="addProject",
            help="Add project (and related information) to the database.",
            helpGroup="PJ", actionGroup="Project")
    def addProject(self, options):

        '''
            Input configuration file for project database. If project exists
            update information, create new project otherwise.
        '''

        config = ConfigParser.RawConfigParser() # Todo: Replace by yaml

        self.out('-Reading project information from %s ...' % options.filename)

        config.read(options.filename)

        session = RSession()

        if config.has_section('projects'):
            pid = config.get('projects', 'pid')
            pi = config.get('projects', 'pi')
            abstract = config.get('projects', 'abstract')
            url = config.get('projects', 'url')
            priority = config.get('projects', 'priority')

            project = session.query(Projects).filter(Projects.pid == pid)
            if len(project[:]) > 0:
                self.out('-Project %s already in database. Updating...' % pid)
                project[0].pi = pi
                project[0].abstract = abstract
                project[0].url = url
                project[0].priority = priority
            else:
                self.out('-Adding %s to the database ...' % pid)
                project = Projects(pid=pid,
                                   pi=pi,
                                   abstract=abstract,
                                   url=url,
                                   priority=priority)

                session.add(project)

        self.out('-Reading observing block information...')

        sct = np.array(config.sections())

        bp_sct = sct[np.array([ss.find('blockpar') for ss in sct]) == 0]

        if bp_sct > 0:
            self.out('--Found %i blocks.' % len(bp_sct))

            for ss in bp_sct:

                b_id = config.get(ss, 'id')
                b_pid = config.get(ss, 'pid')
                maxairmass = config.get(ss, 'maxairmass')
                minairmass = config.get(ss, 'minairmass')
                maxmoonBright = config.get(ss, 'maxmoonBright')
                minmoonBright = config.get(ss, 'minmoonBright')
                minmoonDist = config.get(ss, 'minmoonDist')
                maxseeing = config.get(ss, 'maxseeing')
                cloudcover = config.get(ss, 'cloudcover')
                schedalgorith = config.get(ss, 'schedalgorith')
                applyextcorr = config.get(ss, 'applyextcorr')

                block = session.query(BlockPar).filter(BlockPar.bid == b_id).filter(BlockPar.pid == b_pid)
                if len(block[:]) > 0:
                    self.out('---Block %s.%s already in database. Updating...' % (b_pid, b_id))
                    block[0].bid = b_id
                    block[0].pid = b_pid
                    block[0].maxairmass = maxairmass
                    block[0].minairmass = minairmass
                    block[0].maxmoonBright = maxmoonBright
                    block[0].minmoonBright = minmoonBright
                    block[0].minmoonDist = minmoonDist
                    block[0].maxseeing = maxseeing
                    block[0].cloudcover = cloudcover
                    block[0].schedalgorith = schedalgorith
                    block[0].applyextcorr = applyextcorr
                else:
                    self.out('---Adding block %s.%s to the database...' % (b_pid, b_id))
                    block = BlockPar(bid=b_id,
                                     pid=b_pid,
                                     maxairmass=maxairmass,
                                     minairmass=minairmass,
                                     maxmoonBright=maxmoonBright,
                                     minmoonBright=minmoonBright,
                                     minmoonDist=minmoonDist,
                                     maxseeing=maxseeing,
                                     cloudcover=cloudcover,
                                     schedalgorith=schedalgorith,
                                     applyextcorr=applyextcorr)
                    session.add(block)
            session.commit()
        else:
            self.out('--No block definition found.')

        self.out('-Done')

    ############################################################################

    @action(long="deleteProject",
            help="Delete project (and related information) from the database.",
            helpGroup="PJ", actionGroup="Project")
    def deleteProject(self, opt):

        if not opt.pid:
            self.err(red('*') + 'Specify project to delete with \'--pid\' ...')
            return -1

        # save a copy
        if os.path.exists(DEFAULT_ROBOBS_DATABASE):
            shutil.copy(DEFAULT_ROBOBS_DATABASE,
                        "%s.%s.bak" % (DEFAULT_ROBOBS_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        # delete all projects and related information
        session = RSession()

        self.out('-Deleting all references of project %s from database.' % opt.pid)

        obsblock = session.query(ObsBlock).filter(ObsBlock.pid == opt.pid)
        for block in obsblock:
            self.out('--Deleting observing block %s.%s.%s ...' % (block.pid,
                                                                  block.blockid,
                                                                  block.objid))
            for blk_action in block.actions:
                session.delete(blk_action)
            session.delete(block)


        blocktargets = session.query(BlockPar).filter(BlockPar.pid == opt.pid)
        for block in blocktargets:
            self.out('--Deleting block %s.%s parameters...' % (block.pid,
                                                               block.bid))
            session.delete(block)

        projects = session.query(Projects).filter(Projects.pid == opt.pid)
        for project in projects:
            self.out('--Deleting project %s' % (project.pid))
            session.delete(project)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="cleanProject",
            help="Clean project database.",
            helpGroup="PJ", actionGroup="Project")
    def cleanProject(self, options):
        # save a copy
        if os.path.exists(DEFAULT_PROGRAM_DATABASE):
            shutil.copy(DEFAULT_PROGRAM_DATABASE,
                        "%s.%s.bak" % (DEFAULT_PROGRAM_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        # delete all projects and related information
        session = RSession()

        self.out('-Cleaning project table from database.')

        obsblock = session.query(ObsBlock).all()
        for block in obsblock:
            self.out('--Deleting observing block %s.%s.%s ...' % (block.pid,
                                                                  block.blockid,
                                                                  block.objid))
            for blk_action in block.actions:
                session.delete(blk_action)
            session.delete(block)

        blocktargets = session.query(BlockPar).all()
        for block in blocktargets:
            self.out('--Deleting block %s.%s parameters...' % (block.pid,
                                                               block.bid))
            session.delete(block)

        projects = session.query(Projects).all()
        for project in projects:
            self.out('--Deleting project %s' % (project.pid))
            session.delete(project)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="addTargets",
            help='Add targets to database from a text file. Does not check for duplicated sources.',
            helpGroup="TR", actionGroup="TR")
    def addTargets(self, opt):

        if not opt.filename:
            self.err(red('*') + 'Input not given. Use \'-f\'...')
            return -1

        self.out('-Reading target list from %s ...' % opt.filename)

        targets = Table.read(opt.filename, format='ascii.csv')

        # minimum required entries in input file
        reqpar = ['ra', 'dec']

        givedEntries = {}

        for name in targets.dtype.names:
            givedEntries[name.lower()] = name

        for r in reqpar:
            if not r in givedEntries.keys():
                self.err(red('*') + 'Required parameter, %s, missing from input file...' % r)
                return -1

        # aditional entries
        addpar = {'name': 'name', 'type': 'type', 'mag': 'targetMag',
                  'epoch': 'targetEpoch',
                  'magfilter': 'magFilter', 'link': 'link'}

        session = RSession()

        for i in range(len(targets)):

            p = None
            try:
                p = Position.fromRaDec(str(targets['RA'][i]),
                                       str(targets['DEC'][i]))
            except ValueError:
                self.err(red('*') + 'Object in line %i has invalid coordinates (%s,%s). Skipping...' % (
                i, targets['RA'][i], targets['DEC'][i]))
                pass
            except:
                raise

            if p:
                tpar = {'targetRa': p.ra.H,
                        'targetDec': p.dec.D}
                for pname in addpar.keys():
                    if pname in givedEntries.keys():
                        tpar[addpar[pname]] = targets[givedEntries[pname]][i]

                target = Targets(**tpar)

                self.out('--Adding %s...' % (target.name))

                session.add(target)

                session.commit()

        self.out('-Done')
        return 0

    ############################################################################

    @action(long="cleanTargetsList",
            help='Delete all targets from the database',
            helpGroup="TR", actionGroup="TR")
    def cleanTargetsList(self, opt):

        # save a copy
        if os.path.exists(DEFAULT_PROGRAM_DATABASE):
            shutil.copy(DEFAULT_PROGRAM_DATABASE,
                        "%s.%s.bak" % (DEFAULT_PROGRAM_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        session = RSession()

        ntargets = int(session.query(Targets).count())

        if ntargets == 0:
            self.out('-Target list is alredy empty')
            session.commit()
            self.out('-Done')
            return 0

        targetList = session.query(Targets).all()

        self.out('-Deleting all %i targets from database' % (ntargets))

        for target in targetList:
            session.delete(target)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="addObservingBlock",
            help='Add observing block definition to the database.',
            helpGroup="OB", actionGroup="OB")
    def addObservingBlock(self, opt):

        if not opt.filename:
            self.err(red('*') + 'Input not given. Use \'-f\'...')
            return -1

        self.out('-Reading observing blocks from %s' % (opt.filename))

        blockList = Table.read(opt.filename, format='ascii.no_header')

        session = RSession()

        for entry in blockList:

            block = entry.data

            # config = ConfigParser.RawConfigParser()
            #
            # config.read(block[3])

            with open(block[3]) as fp:
                try:
                    config = yaml.load(fp)
                except yaml.YAMLError as exc:
                    self.exit(exc)

            target = session.query(Targets).filter(Targets.id == block[2])
            if target.count() == 0:
                self.exit("No target defined for specified block %i." % block[1])

            addblock = session.query(ObsBlock).filter(ObsBlock.objid == block[2]).filter(
                ObsBlock.blockid == block[1]).filter(ObsBlock.pid == block[0])

            if addblock.count() > 0:
                self.out(red('<<')+'Deleting %i blocks.' % addblock.count())
                for bl in addblock:
                    for blk_action in bl.actions:
                        self.out(red('<<')+'Deleting: %s' % blk_action)
                        session.delete(blk_action)
                    session.delete(bl)
                    session.commit()

            self.out(blue('>>')+'Adding block: %s' % block)
            addblock = ObsBlock(objid=block[2],
                                blockid=block[1],
                                pid=block[0],
                                bparid=block[4])

            # process pre-slew actions
            if 'pre-actions' in config:
                for actconfig in config['pre-actions']:
                    act = actionDict[actconfig['action']]()
                    self.out('Action: %s' % actconfig['action'])

                    if actconfig['action'] == 'point':
                        if 'ra' in actconfig.keys() and 'dec' in actconfig.keys():
                            epoch = 'J2000' if 'epoch' not in actconfig.keys() else actconfig['epoch']
                            position = Position.fromRaDec(actconfig['ra'], actconfig['dec'], epoch)
                            self.out('Coords: %s' % position)
                            act.targetRaDec = position
                            # act = Point(targetRaDec=position)
                        elif 'alt' in actconfig.keys() and 'az' in actconfig.keys():
                            position = Position.fromAltAz(actconfig['alt'], actconfig['az'])
                            self.out('Coords: %s' % position)
                            act.targetAltAz = position
                        else:
                            self.out('Target name: %s' % actconfig['name'])
                            act.targetName = actconfig['name']

                    else:
                        for key in actconfig.keys():
                            if hasattr(act, key) and key != 'action':
                                value = actconfig[key]
                                if type(value) == str:
                                    fmt = target[0].__dict__
                                    fmt.update(addblock.__dict__)
                                    value = value.format(**fmt)

                                self.out('\t%s: %s' % (key, value))
                                try:
                                    setattr(act, key, value)
                                except:
                                    self.err('Could not set attribute %s = %s on action %s' % (key,
                                                                                               actconfig[key],
                                                                                               actconfig['action']))
                    addblock.actions.append(act)

            # Slew to target
            position = Position.fromRaDec(target[0].targetRa, target[0].targetDec, 'J2000')
            slewto = Point()
            slewto.targetRaDec = position
            addblock.actions.append(slewto)

            # process pos-slew actions
            for actconfig in config['pos-actions']:
                act = actionDict[actconfig['action']]()
                self.out('Action: %s' % actconfig['action'])

                if actconfig['action'] == 'point':
                    if 'ra' in actconfig.keys() and 'dec' in actconfig.keys():
                        epoch = 'J2000' if 'epoch' not in actconfig.keys() else actconfig['epoch']
                        position = Position.fromRaDec(actconfig['ra'], actconfig['dec'], epoch)
                        self.out('Coords: %s' % position)
                        act.targetRaDec = position
                        # act = Point(targetRaDec=position)
                    elif 'alt' in actconfig.keys() and 'az' in actconfig.keys():
                        position = Position.fromAltAz(actconfig['alt'], actconfig['az'])
                        self.out('Coords: %s' % position)
                        act.targetAltAz = position
                    else:
                        self.out('Target name: %s' % actconfig['name'])
                        act.targetName = actconfig['name']

                else:
                    for key in actconfig.keys():
                        if hasattr(act, key) and key != 'action':
                            value = actconfig[key]
                            if type(value) == str:
                                fmt = target[0].__dict__
                                fmt.update(addblock.__dict__)
                                value = value.format(**fmt)

                            self.out('\t%s: %s' % (key, value))
                            try:
                                setattr(act, key, value)
                            except:
                                self.err('Could not set attribute %s = %s on action %s' % (key,
                                                                                           actconfig[key],
                                                                                           actconfig['action']))
                addblock.actions.append(act)


            session.add(addblock)

            session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="cleanObservingBlock",
            help='Delete all observing blocks from the database.',
            helpGroup="OB", actionGroup="OB")
    def cleanObservingBlock(self, opt):

        # save a copy
        if os.path.exists(DEFAULT_PROGRAM_DATABASE):
            shutil.copy(DEFAULT_PROGRAM_DATABASE,
                        "%s.%s.bak" % (DEFAULT_PROGRAM_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        session = RSession()

        nblocks = int(session.query(ObsBlock).count())

        if nblocks == 0:
            self.out('-Observing block list is alredy empty')
            session.commit()
            self.out('-Done')
            return 0

        self.out('-Deleting all %i observing blocks from database' % (nblocks))

        blockList = session.query(ObsBlock).all()

        for block in blockList:
            for blk_action in block.actions:
                session.delete(blk_action)
            session.delete(block)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="deleteObservingBlock",
            help='Delete observing blocks of a specific project (PID) from the database.',
            helpGroup="OB", actionGroup="OB")
    def deleteObservingBlock(self, opt):

        if not opt.pid:
            self.err(red('*') + 'Specify project to delete with \'--pid\' ...')
            return -1

        # save a copy
        if os.path.exists(DEFAULT_ROBOBS_DATABASE):
            shutil.copy(DEFAULT_ROBOBS_DATABASE,
                        "%s.%s.bak" % (DEFAULT_ROBOBS_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        session = RSession()

        nblocks = int(session.query(ObsBlock).filter(ObsBlock.pid == opt.pid).count())

        if nblocks == 0:
            self.out('-No observing block with PID=%s to delete' % opt.pid)
            session.commit()
            self.out('-Done')
            return 0

        self.out('-Deleting all %i observing blocks with PID=%s from database' % (nblocks, opt.pid))

        blockList = session.query(ObsBlock).filter(ObsBlock.pid == opt.pid).all()

        for block in blockList:
            for blk_action in block.actions:
                session.delete(blk_action)
            session.delete(block)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="showObservingLog",
            help="Show entries on Observing Log database. User can specify start/end dates, only start or end works as well.",
            actionGroup="")
    def showObservingLog(self,opt):

        session = RSession()

        self.mktimes(opt)

        query = session.query(ObservingLog).filter(ObservingLog.time > self.obsStart-dt.timedelta(hours=2),
                                                   ObservingLog.time <= self.obsEnd).order_by(ObservingLog.time+dt.timedelta(hours=2))

        for q in query:
            self.out('%s'%q)

    ############################################################################

    @action(long="makeObservingLog",
            help="Process entries on Observing Log database and generate charts and graphs with observing information. User can specify start/end dates, only start or end works as well.",
            actionGroup="")
    def makeObservingLog(self,opt):
        import matplotlib
        matplotlib.use('macosx')
        import pylab as py
        # import plotly.plotly as py
        # from plotly.graph_objs import Data,Scatter,Layout,Figure,YAxis,Line

        session = RSession()

        self.mktimes(opt)

        query = session.query(ObservingLog).filter(ObservingLog.time > self.obsStart-dt.timedelta(hours=2),
                                                   ObservingLog.time <= self.obsEnd+dt.timedelta(hours=2))

        tid = np.array([],dtype=np.int)

        for q in query:
            tid = np.append(tid,q.tid)
            #self.out('%s'%q)

        tid = np.unique(tid)

        # site = self.site()
        trace = []

        color = {0 : 'red',
                 1 : 'blue'}

        alt_min= 30
        alt_max= 90

        # print self.obsStart, self.site.LST_inRads(self.obsStart)
        py.plot([self.obsStart,self.obsStart],
                [alt_min,alt_max],'r--')
        py.plot([self.obsEnd,self.obsEnd],
                [alt_min,alt_max],'r--')
        py.plot([self.obsStart-dt.timedelta(hours=2),self.obsEnd+dt.timedelta(hours=2)],
                [alt_min+10,alt_min+10],'r--')

        for id in tid:
            target = session.query(Targets).filter(Targets.id == id)[0]
            time,alt = self.altitude(ra = target.targetRa,
                                     dec = target.targetDec,
                                     start = self.obsStart-dt.timedelta(hours=5),
                                     end = self.obsEnd+dt.timedelta(hours=2),
                                     tdelta=1./30.)

            py.plot(time,alt,'b-')
            # trace.append(Scatter(x = time,
            #                      y = alt, #np.exp(1.-1./secz)
            #                      mode='lines',
            #                      line=Line(
            #                             color='red',
            #                             width=0.5
            #                             )
            #                      )
            #              )

            targetObs = query.filter(ObservingLog.tid == id)
            start = []
            end = []

            for obs in targetObs:
                if 'Acquisition Start' in obs.action:
                    start.append(obs.time)
                elif 'Acquisition End' in obs.action:
                    end.append(obs.time)
            if len(start) != len(end):
                self.err('Start/end of observations of target does not match')
                continue

            ylim = py.ylim()
            for i in range(len(start)):
                time,alt = self.altitude(ra = target.targetRa,
                                         dec = target.targetDec,
                                         start = start[i],
                                         end = end[i],
                                         tdelta=1./60.)
                py.fill_between(time,alt,ylim[0],facecolor='green', alpha=0.5)
                # trace.append(Scatter(x = time,
                #                      y = alt, #np.exp(1.-1./secz)
                #                      mode='lines',
                #                      line=Line(
                #                             color=color[int(targetObs[i].priority)],
                #                             width=1.0
                #                             ),
                #                      fill='tozeroy',
                #                      name=target.name
                #                      )
                #              )
            py.ylim(ylim)

        # print xlim
        # py.xlim(xlim)
        py.xlim(self.obsStart-dt.timedelta(hours=2),self.obsEnd+dt.timedelta(hours=2))
        py.ylim(alt_min,alt_max)

        # py.show()
        py.savefig('foo.png')
        # data = Data(trace)
        # layout = Layout(yaxis=YAxis(autorange='reversed'))
        # fig = Figure(data=data)#, layout=layout)
        # plot_url = py.plot(fig, filename='airmass')

    ############################################################################

    @action(long="cleanObservingLog",
            help="Delete entries on Observing Log database. If no date is specified swipe clean the log database. User can specify start/end dates, only start or end works as well.",
            actionGroup="")
    def cleanObservingLog(self,opt):

        session = RSession()

        self.mktimes(opt)
        # Query all obs logs entries

        query = session.query(ObservingLog).filter(ObservingLog.time > self.obsStart-dt.timedelta(hours=2),
                                                   ObservingLog.time <= self.obsEnd+dt.timedelta(hours=2))

        for q in query:
            session.delete(q)
            session.commit()

    @action(long="cleanQueue",
            help="Delete all scheduled blocks from specified project.",
            actionGroup="")
    def cleanQueue(self,opt):

        session = RSession()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(Projects).filter(Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        self.out('-Deleting all scheduled observing blocks from project %s from the queue.'%opt.PID)

        programs = session.query(Program).filter(Program.pid == opt.PID)

        for p in programs:
            self.out(red('--Deleting'))
            self.out( red('---')+'%s'%p )
            # for act in p.actions:
            #     session.delete(act)
            #     self.out( red('---')+'%s'%act)
            session.delete(p)
            self.out(red('--Done'))

        session.commit()

        sched_blocks = session.query(ObsBlock).filter(ObsBlock.pid == opt.PID,
                                                      ObsBlock.scheduled == 1)

        for sb in sched_blocks:
            sb.scheduled = 0

        for sched in schedAlgorithms:
            schedAlgorithms[sched].clean(opt.PID)


        session.commit()

        return 0

    ############################################################################

    @action(long="makeQueue",
            help="Select targets from specified project to be observed. ",
            actionGroup="")
    def makeQueue(self,opt):

        session = RSession()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(Projects).filter(Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        if self.checkQueue(opt.PID):
            self.out(red('+')+'Project already processed... Reprocessing a queue is a nasty job... Clean it and try again...')
            session.commit()
            return 0

        pgrconfig = {}
        if opt.PIDCONFIG is not None:
            with open(opt.PIDCONFIG, 'r') as stream:
                try:
                    pgrconfig = yaml.load(stream)
                except yaml.YAMLError as exc:
                    self.exit(exc)


        self.out('-Selecting targets from project %s'%opt.PID)

        self.mktimes(opt)

        obsStart = self.obsStart
        obsEnd = self.obsEnd
        lststart = self.lststart-2.
        lstend = self.lstend+2.
        remoteManager = self.robobs.getManager()
        site = remoteManager.getProxy(remoteManager.getResourcesByClass("Site")[0])

        self.out('-Observation start @ %s | LST = %4.1f h'%(str(obsStart)[:19],lststart))
        self.out('-Observation end   @ %s | LST = %4.1f h'%(str(obsEnd)[:19],lstend))

        obsStart = site.JD(obsStart)
        obsEnd = site.JD(obsEnd)

        ohh = int(np.floor( (obsEnd-obsStart)*24. ))
        omm = int( np.floor( ((obsEnd-obsStart)*24. - ohh) * 60. ))
        self.out('-Observing time: %02i:%02i h'%(ohh,omm))

        # Look for suitable observing blocks for this night...
        FLAG = opt.PID

        ## Select all observing blocks from this project that where not observed
        ## and are not scheduled for observations

        targets = session.query(Targets)
        for target in targets:
            target.lst = self.lststart.H
            # self.out('%s %.2f %.2f' % (target,target.targetRa,target.targetAH))
        session.commit()
        # targets = session.query(Targets).order_by(Targets.targetAH)
        # for target in targets:
        #     self.out('%s %.2f %.2f' % (target,target.targetRa,target.targetAH))

        tList = None
        if lststart < lstend:
            tList = session.query(ObsBlock,BlockPar,Targets).filter(ObsBlock.pid == FLAG,
                                                                    BlockPar.pid == FLAG,
                                                                    ObsBlock.scheduled == False,
                                                                    ObsBlock.observed == False,
                                                                    Targets.targetRa > lststart,
                                                                    Targets.targetRa < lstend).join(BlockPar).join(
                Targets).order_by(desc(Targets.targetAH))
        else:

            tList = session.query(ObsBlock, BlockPar, Targets).filter(ObsBlock.pid == FLAG,
                                                                      BlockPar.pid == FLAG,
                                                                      ObsBlock.scheduled == False,
                                                                      ObsBlock.observed == False,
                                                                      or_(and_(Targets.targetRa > lststart,
                                                                               Targets.targetRa < 24.),
                                                                          and_(Targets.targetRa > 0.,
                                                                               Targets.targetRa < lstend))).join(
                Targets).order_by(desc(Targets.targetAH))

        if len(tList[:]) == 0:
            self.out(blue('+') + 'No targets available from this project this night...')
            session.commit()
            return -1

        self.out('-Found %i suitable targets...'%(len(tList[:])))

        schedAlgList = np.array([t[1].schedalgorith for t in tList])
        uSAL = np.unique(schedAlgList)

        self.out('-Found %i types of scheduling algorith...'%(len(uSAL)))
        for i,sa_type in enumerate(uSAL):
            self.out('--SA Type[%i] = %i'%(i+1,sa_type))

        for sAL in uSAL:

            nquery = tList.filter(BlockPar.schedalgorith == sAL)

            sched = schedAlgorithms[sAL]

            # qFunction = algorithms.ScheduleFunction(sAL,
            #                                         obsStart=obsStart,
            #                                         obsEnd=obsEnd,
            #                                         s=self,
            #                                         query=nquery,
            #                                         site=site)

            obsTargets = sched.process(self.bestSlotLen(opt.PID),
                                       obsStart=obsStart,
                                       obsEnd=obsEnd,
                                       query=nquery,
                                       site=site,
                                       config=pgrconfig)

            # First schedule all
            for bid in obsTargets:
                if bid['blockid'] > 0:
                    oblock = nquery.filter(ObsBlock.blockid == bid['blockid'])
                    self.addObservation(oblock,bid['start'])

            # Now mark as scheduled
            for bid in obsTargets:
                if bid['blockid'] > 0:
                    oblock = nquery.filter(ObsBlock.blockid == bid['blockid'])
                    for o in oblock:
                        o[0].scheduled = True
                    session.commit()

        session.commit()

    ############################################################################

    @action(help="Start manager", helpGroup="RUN", actionGroup="RUN")
    def start(self, options):

        robobs = self.robobs
        self.out('Starting robobs... ',end='')

        if robobs.start():
            self.out(green('OK'))
        else:
            self.out(red("FAILED"))

        return 0

    ############################################################################
    @action(help="Start scheduler", helpGroup="RUN", actionGroup="RUN")
    def wake(self, options):

        robobs = self.robobs

        robobs.wake()

        return 0

    ############################################################################

    @action(help="Stop manager", helpGroup="RUN", actionGroup="RUN")
    def stop(self, options):

        robobs = self.robobs

        self.out('Stopping robobs... ',end='')
        if robobs.stop():
            self.out(green('OK'))
        else:
            self.out(red('FAILED'))

        return 0

    ############################################################################

    @action(help="Monitor manager", helpGroup="RUN", actionGroup="RUN")
    def monitor(self, options):

        return 0

    ############################################################################

    @action(long="processQueue",
            help="Process queue like chimera will do during an observation.",
            actionGroup="")
    def processQueue(self,opt):

        self.mktimes(opt)

        site = self.site
        telescope = self.telescope
        obsStart = site.JD(self.obsStart)-2400000.5
        obsEnd = site.JD(self.obsEnd)-2400000.5
        lststart = self.lststart
        lstend = self.lstend


        otime = obsStart

        appOpen = 0.
        idle = 0.

        # qExec = queue.QueueScheduler(site)

        session = RSession()
        telPos = None #current telescope position

        while otime < obsEnd:
            #aP,aplen = self.getAlternateProgram(aprograms,time)
            #if aplen < 0:
            #    break
            self.out('Requesting target @ %f'%otime, end='')
            program_list = self.robobs.reshedule(otime)
            if not program_list:
                break
            program = session.merge(program_list[0])
            self.out('slew@: %s' % program.slewAt)

            program = session.merge(program)
            aplen = self.calcObsTime(program,20.)

            #while 0 <  aplen/86.4e3 < idleTime:
            msg = ''
            slewAt = float(program.slewAt)
            _idle = slewAt - otime
            # if _idle*24.*60.*60. < aplen:
            #     slewAt = otime
            #     _idle = 0.
            # print slewAt,otime
            stime = otime
            if _idle > 1e-5:
                msg += '[info: Program slew %.3fm in the future. waiting...]'%( (_idle)*24.*60. )
                idle += _idle
                stime+=_idle
            elif _idle < -1e-5:
                msg += '[info: Program slew %.3fm in the past. Slewing now...]'%  ( (_idle)*24.*60. )

            _idle = _idle if _idle > 0 else 0.
            slewtime = 0.
            target = session.query(Targets).filter(Targets.id == program.tid).first()
            # check that target is at correct altitude.

            targetPos = Position.fromRaDec(target.targetRa,target.targetDec)
            if telPos:
                adist = telPos.angsep(targetPos)
                slewtime = np.float(adist.toAS())/60./60./86.4e3 # consider 1 arcmin / second
            slewtime = slewtime if slewtime > _idle else 0 # if slewtime larger than idle time slewtime will be zero
            msg += ' | slewtime = %.5fm'%(slewtime*60.*60.)
            self.out('@ %.5f (%.5f): Acquiring %45s %s (len: %.2f)'%(otime,slewAt,program,msg, aplen))
            log = ObservingLog(time=datetimeFromJD(stime+2400000.5,),
                                 tid=program.tid,
                                 name=program.name,
                                 priority=program.priority,
                                 action='Simulation: Acquisition Start')
            session.add(log)
            session.commit()

            log = ObservingLog(time=datetimeFromJD(stime+(aplen/86.4e3)+2400000.5,),
                         tid=program.tid,
                         name=program.name,
                         priority=program.priority,
                         action='Simulation: Acquisition End')
            session.add(log)

            dt = (aplen/86.4e3) + slewtime + _idle
            otime+=dt

            appOpen+=aplen
            program.finished = True
            session.commit()

            blockpar= session.merge(program_list[1])
            self.out('%s: %i %s' % (blockpar,blockpar.schedalgorith,schedAlgorithms[blockpar.schedalgorith].name()))
            remoteManager = self.robobs.getManager()

            schedAlgorithms[blockpar.schedalgorith].observed(otime,program_list,
                                                             site = remoteManager.getProxy(
                                                                 remoteManager.getResourcesByClass("Site")[0]))
            telPos = targetPos
            session.commit()

        aprograms = session.query(Program).filter(Program.finished == True)

        for ap in aprograms:
            ap.finished = False

        allpid = [ p.pid for p in session.query(Projects)]

        session.commit()
        for sched in schedAlgorithms:
            for pid in allpid:
                schedAlgorithms[sched].soft_clean(pid)

        session.commit()

        self.out('@ %.4f: Idle for %.2fh'%(otime,(obsEnd-otime)*24.))
        idle += (obsEnd-otime)
        self.out('@ %.4f: Night end'%obsEnd)
        self.out('-Total idle time: %.2fh'%(idle*24.))
        self.out('-Total open shutter time: %.2fh'%(appOpen/60./60.))

    ############################################################################

    def mktimes(self,opt):
        # Determining start/end times

        remoteManager = self.robobs.getManager()
        site = remoteManager.getProxy(remoteManager.getResourcesByClass("Site")[0])

        self.obsStart = site.sunset_twilight_end()
        self.obsEnd = site.sunrise_twilight_begin(self.obsStart)

        if opt.JDstart:
            self.obsStart = datetimeFromJD(opt.JDstart)
        elif opt.dstart:
            day,hour = opt.dstart.split('-')
            yy,mm,dd = [int(val) for val in day.split('/')]
            hh,mi,ss = [int(val) for val in hour.split(':') ]
            self.obsStart = dt.datetime(yy,mm,dd,hh,mi,ss)

        if opt.JDend:
            self.obsEnd = datetimeFromJD(opt.JDend)
        elif opt.dend:
            day,hour = opt.dend.split('-')
            yy,mm,dd = [int(val) for val in day.split('/')]
            hh,mi,ss = [int(val) for val in hour.split(':') ]
            self.obsEnd = dt.datetime(yy,mm,dd,hh,mi,ss)

        self.lststart = site.LST(self.obsStart).toH()
        self.lstend = site.LST(self.obsEnd).toH()
        self.lststart_deg = site.LST(self.obsStart).toD()
        self.lstend_deg = site.LST(self.obsEnd).toD()
        self.mjdStart = site.MJD(self.obsStart)
        self.mjdEnd =  site.MJD(self.obsEnd)

    ############################################################################

    def calcObsTime(self,program,rot=0.):
        otime = 0.

        session = RSession()
        obs_block = session.query(ObsBlock).filter(ObsBlock.id == program.obsblock_id).first()
        for ii,act in enumerate(obs_block.actions):
            if act.__tablename__ == 'action_expose':
                otime+=(act.exptime+rot)*act.frames
        return otime

    ############################################################################

    def checkQueue(self, PID):
        '''Check if projet was already processed...
            '''

        session = RSession()

        progs = session.query(Program).filter(Program.pid == PID).first()

        if progs is not None:
            session.commit()
            return True

        session.commit()
        return False

    ############################################################################

    def bestSlotLen(self,pid):

        # FIXME

        # session = RSession()
        #
        # query = session.query(ObsBlock).filter(ObsBlock.pid == pid).filter(ObsBlock.blockid == blkid)
        #
        # # slen = 0
        #
        # tottime = 0.
        #
        # bid = -1
        # for blk in query:
        #     for blk_action in blk.actions:
        #         # Todo: Add overheads: Pointing, autofocus, readout, filter,...
        #         if blk_action.__tablename__ == 'action_expose':
        #             tottime += blk_action.exptime * blk_action.frames
        # session.commit()

        return 15.

    ############################################################################

    def addObservation(self,block,obstime):

        session = RSession()

        self.out('%s'%block[:][0][0])

        programs = []

        for subblock in block:

            objname = subblock[2].name
            pquery = session.query(Projects).filter(Projects.pid == subblock[0].pid)

            program = Program(tid=subblock[0].objid,
                              name = objname,
                              pi='',
                              priority=pquery[0].priority,
                              slewAt=obstime-2400000.5,
                              pid=subblock[0].pid,
                              obsblock_id=subblock[0].id,
                              blockpar_id=subblock[1].id
                              )#,exposeAt=obstime)
            # for blk_actions in subblock[0].actions:
            #     program.actions.append(blk_actions)

            programs.append(program)

            sched_add = schedAlgorithms[subblock[1].schedalgorith]
            sched_add.add(subblock)

        session.add_all(programs)
        session.commit()

        # algorith specific process


    def altitude(self,ra,dec,start,end,tdelta=0.5,minA=10.):

        site = self.site

        coords = Position.fromRaDec(ra,
                                 dec)

        timevec = np.array([])
        amvec = np.array([])

        time = start
        while time < end:
        #for time in range(start,end,dt.timedelta(hours=tdelta)):
            #print type(time)
            lst = site.LST_inRads(time)
            alt = float(site.raDecToAltAz(coords,lst).alt)
            # airmass = 1./np.cos(np.pi/2.-alt*np.pi/180.)
            if minA < alt <= 90.:
                timevec = np.append(timevec,time)
                amvec = np.append(amvec,alt)
            time += dt.timedelta(hours=tdelta)

        return timevec,amvec

################################################################################

def main():
    cli = RobObs()
    cli.run(sys.argv)
    cli.wait()

################################################################################

if __name__ == '__main__':
    main()

################################################################################
