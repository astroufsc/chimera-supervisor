#!/usr/bin/env python

################################################################################

__author__ = 'Ribeiro, T.'

################################################################################

import sys
import os
import time
import datetime as dt
import shutil
import re
import yaml
import numpy as np
import ConfigParser
from astropy.table import Table
from sqlalchemy import (or_,and_, desc, asc)
import inspect

from chimera.core.cli import ChimeraCLI, action, ParameterType
from chimera.core.site import datetimeFromJD
from chimera.core.callback import callback
from chimera.core.exceptions import printException, ObjectNotFoundException
from chimera.util.output import blue, green, red
from chimera.util.position import Position
from chimera.util.coord import Coord

from chimera_supervisor.core.constants import DEFAULT_PROGRAM_DATABASE, DEFAULT_ROBOBS_DATABASE
from chimera_supervisor.controllers.scheduler.model import Session as RSession
from chimera_supervisor.controllers.scheduler.model import (Projects, BlockPar, ObsBlock,
                                                            Targets, ObservingLog,
                                                            Program, AutoFocus, AutoFlat, PointVerify, Point, Expose)
from chimera_supervisor.controllers.scheduler import algorithms
from matplotlib.dates import DateFormatter

schedAlgorithms = {}
for name,obj in inspect.getmembers(algorithms):
    if inspect.isclass(obj) and issubclass(obj,algorithms.BaseScheduleAlgorith):
        schedAlgorithms[obj.id()] = obj

actionDict = {'autofocus' : AutoFocus,
              'autoflat' : AutoFlat,
              'pointverify' : PointVerify,
              'point' : Point,
              'expose' : Expose,
              }
################################################################################

class RobObs(ChimeraCLI):
    ############################################################################

    def __init__(self):
        ChimeraCLI.__init__(self, "chimera-robobs",
                            "RobObs controller", 0.0, port=9010)

        '''
        Check manager status and control some actions.
        '''

        self.addHelpGroup("ROBOBS", "RobObs")
        self.addController(name="site",
                           cls="Site",
                           required=True,
                           help="Observing site",
                           helpGroup="OBSERVATORY")

        self.addController(name="telescope",
                           cls="telescope",
                           required=False,
                           help="Telescope to me used. It is used during queue processing for estimating slew time.",
                           helpGroup="TELESCOPE")

        self.addController(name="robobs",
                           cls="RobObs",
                           required=True,
                           help="Robobs controller to be used",
                           helpGroup="ROBOBS")

        self.addHelpGroup("RUN", "Start/Stop/Monitor")
        self.addParameters(dict(name="filename", long="file", short="f",
                                default="",
                                help="Filename with program or block information.",
                                metavar="FILENAME",
                                helpGroup="RUN"))

        self.addHelpGroup("SCHEDULER", "Scheduler")
        self.addParameters(dict(name="PID", long="pid", type='string',
                                help="Project ID flag. Use to select targets from DB.",
                                metavar="PID",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="PIDCONFIG", long="pid-config", type='string',
                                help="A Project (yaml) configuration file. This is read and passed as a dictionary to"
                                     "the project scheduling algorithm.",
                                metavar="PIDCONFIG",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="JDstart", long="jdstart", type=float,
                                help="Julian date of the start of the observations to be scheduled. Override date.",
                                metavar="JDstart",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="JDend", long="jdend", type=float,
                                help="Julian date at the end of the observations to be scheduled. Override date.",
                                metavar="JDend",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="dstart", long="dateStart", type='string',
                                help="Date (yyyy/mm/dd-hh:mm:ss) of the start of the observations to be scheduled.",
                                metavar="dstart",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="dend", long="dateEnd", type='string',
                                help="Date (yyyy/mm/dd-hh:mm:ss.s) of the end of the observations to be scheduled.",
                                metavar="dend",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="yesterday", long="yesterday",
                                type=ParameterType.BOOLEAN,
                                default=False,
                                help="Set start/end dates for yesterday (subtract 1d from times) for"
                                     " target selection cuts. Usefull for plotting last observed night.",
                                metavar="yesterday",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="LSTstart", long="lststart", type=float,
                                help="Overwrite LST target selection cut. Does not change start/end of night only the"
                                     " target selection cuts. Usefull to extend cut on thin projects.",
                                metavar="LSTstart",
                                helpGroup="SCHEDULER"))
        self.addParameters(dict(name="LSTend", long="lstend", type=float,
                                help="Overwrite LST target selection cut. Does not change start/end of night only the"
                                     " target selection cuts. Usefull to extend cut on thin projects.",
                                metavar="LSTend",
                                helpGroup="SCHEDULER"))

        self.addParameters(dict(name="simulation",
                                long="simulation",
                                type=ParameterType.BOOLEAN,
                                default=False,
                                helpGroup="SCHEDULER",
                                help="Make observing log for simulation."))

    ############################################################################

    @action(long="addProject",
            help="Add project (and related information) to the database.",
            helpGroup="PJ", actionGroup="Project")
    def addProject(self, options):

        '''
            Input configuration file for project database. If project exists
            update information, create new project otherwise.
        '''

        self.out('-Reading project information from %s ...' % options.filename)

        with open(options.filename, 'r') as fp:
            try:
                config = yaml.load(fp)
            except yaml.YAMLError as exc:
                self.exit(exc)

        session = RSession()

        if 'project' in config:
            pid = config['project']['pid']
            pi = config['project']['pi']
            abstract = config['project']['abstract']
            url = config['project']['url']
            priority = config['project']['priority']

            project = session.query(Projects).filter(Projects.pid == pid)
            if len(project[:]) > 0:
                self.out('-Project %s already in database. Updating...' % pid)
                project[0].pi = pi
                project[0].abstract = abstract
                project[0].url = url
                project[0].priority = priority
            else:
                self.out('-Adding %s to the database ...' % pid)
                project = Projects(pid=pid,
                                   pi=pi,
                                   abstract=abstract,
                                   url=url,
                                   priority=priority)

                session.add(project)
        else:
            self.exit('[%s] - No project section defined in configuration file.' % (red('ERROR')))

        self.out('-Reading observing block information...')

        if 'observing_blocks' in config:
            blockpar_list = ['id', 'pid', 'maxairmass', 'minairmass', 'maxmoonBright', 'minmoonBright', 'minmoonDist',
                             'maxseeing', 'cloudcover', 'schedalgorith', 'applyextcorr']

            self.out('--Found %i blocks.' % len(config['observing_blocks']))
            for observing_block in config['observing_blocks']:

                b_id = config['observing_blocks'][observing_block]['id']
                b_pid = config['observing_blocks'][observing_block]['pid']
                block = session.query(BlockPar).filter(BlockPar.bid == b_id).filter(BlockPar.pid == b_pid).first()
                add = False
                if block is None:
                    self.out('---Adding block %s.%s to the database...' % (b_pid, b_id))
                    block = BlockPar(bid=b_id,
                                     pid=b_pid)
                    add = True
                else:
                    self.out('---Block %s.%s already in database. Updating...' % (b_pid, b_id))

                for par in blockpar_list:
                    if par in config['observing_blocks'][observing_block] and (par not in ['id', 'pid']):
                        self.out(' %s: %s' % (par,config['observing_blocks'][observing_block][par]))
                        setattr(block,par,config['observing_blocks'][observing_block][par])
                if add:
                    session.add(block)
            session.commit()
        else:
            self.out('--No block definition found.')

        self.out('-Done')

    ############################################################################

    @action(long="deleteProject",
            help="Delete project (and related information) from the database.",
            helpGroup="PJ", actionGroup="Project")
    def deleteProject(self, opt):

        if not opt.pid:
            self.err(red('*') + 'Specify project to delete with \'--pid\' ...')
            return -1

        # save a copy
        if os.path.exists(DEFAULT_ROBOBS_DATABASE):
            shutil.copy(DEFAULT_ROBOBS_DATABASE,
                        "%s.%s.bak" % (DEFAULT_ROBOBS_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        # delete all projects and related information
        session = RSession()

        self.out('-Deleting all references of project %s from database.' % opt.pid)

        obsblock = session.query(ObsBlock).filter(ObsBlock.pid == opt.pid)
        for block in obsblock:
            self.out('--Deleting observing block %s.%s.%s ...' % (block.pid,
                                                                  block.blockid,
                                                                  block.objid))
            for blk_action in block.actions:
                session.delete(blk_action)
            session.delete(block)


        blocktargets = session.query(BlockPar).filter(BlockPar.pid == opt.pid)
        for block in blocktargets:
            self.out('--Deleting block %s.%s parameters...' % (block.pid,
                                                               block.bid))
            session.delete(block)

        projects = session.query(Projects).filter(Projects.pid == opt.pid)
        for project in projects:
            self.out('--Deleting project %s' % (project.pid))
            session.delete(project)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="cleanProject",
            help="Clean project database.",
            helpGroup="PJ", actionGroup="Project")
    def cleanProject(self, options):
        # save a copy
        if os.path.exists(DEFAULT_PROGRAM_DATABASE):
            shutil.copy(DEFAULT_PROGRAM_DATABASE,
                        "%s.%s.bak" % (DEFAULT_PROGRAM_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        # delete all projects and related information
        session = RSession()

        self.out('-Cleaning project table from database.')

        obsblock = session.query(ObsBlock).all()
        for block in obsblock:
            self.out('--Deleting observing block %s.%s.%s ...' % (block.pid,
                                                                  block.blockid,
                                                                  block.objid))
            for blk_action in block.actions:
                session.delete(blk_action)
            session.delete(block)

        blocktargets = session.query(BlockPar).all()
        for block in blocktargets:
            self.out('--Deleting block %s.%s parameters...' % (block.pid,
                                                               block.bid))
            session.delete(block)

        projects = session.query(Projects).all()
        for project in projects:
            self.out('--Deleting project %s' % (project.pid))
            session.delete(project)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="addTargets",
            help='Add targets to database from a text file. Does not check for duplicated sources.',
            helpGroup="TR", actionGroup="TR")
    def addTargets(self, opt):

        if not opt.filename:
            self.err(red('*') + 'Input not given. Use \'-f\'...')
            return -1

        self.out('-Reading target list from %s ...' % opt.filename)

        targets = Table.read(opt.filename, format='ascii.csv')

        # minimum required entries in input file
        reqpar = ['ra', 'dec']

        givedEntries = {}

        for name in targets.dtype.names:
            givedEntries[name.lower()] = name

        for r in reqpar:
            if not r in givedEntries.keys():
                self.err(red('*') + 'Required parameter, %s, missing from input file...' % r)
                return -1

        # aditional entries
        addpar = {'name': 'name', 'type': 'type', 'mag': 'targetMag',
                  'epoch': 'targetEpoch',
                  'magfilter': 'magFilter', 'link': 'link'}

        session = RSession()

        for i in range(len(targets)):

            p = None
            try:
                p = Position.fromRaDec(str(targets['RA'][i]),
                                       str(targets['DEC'][i]))
            except ValueError:
                self.err(red('*') + 'Object in line %i has invalid coordinates (%s,%s). Skipping...' % (
                i, targets['RA'][i], targets['DEC'][i]))
                pass
            except:
                raise

            if p:
                tpar = {'targetRa': p.ra.H,
                        'targetDec': p.dec.D}
                for pname in addpar.keys():
                    if pname in givedEntries.keys():
                        tpar[addpar[pname]] = targets[givedEntries[pname]][i]

                target = Targets(**tpar)

                self.out('--Adding %s...' % (target.name))

                session.add(target)

                session.commit()

        self.out('-Done')
        return 0

    ############################################################################

    @action(long="cleanTargetsList",
            help='Delete all targets from the database',
            helpGroup="TR", actionGroup="TR")
    def cleanTargetsList(self, opt):

        # save a copy
        if os.path.exists(DEFAULT_PROGRAM_DATABASE):
            shutil.copy(DEFAULT_PROGRAM_DATABASE,
                        "%s.%s.bak" % (DEFAULT_PROGRAM_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        session = RSession()

        ntargets = int(session.query(Targets).count())

        if ntargets == 0:
            self.out('-Target list is alredy empty')
            session.commit()
            self.out('-Done')
            return 0

        targetList = session.query(Targets).all()

        self.out('-Deleting all %i targets from database' % (ntargets))

        for target in targetList:
            session.delete(target)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="addObservingBlock",
            help='Add observing block definition to the database.',
            helpGroup="OB", actionGroup="OB")
    def addObservingBlock(self, opt):

        if not opt.filename:
            self.err(red('*') + 'Input not given. Use \'-f\'...')
            return -1

        self.out('-Reading observing blocks from %s' % (opt.filename))

        blockList = Table.read(opt.filename, format='ascii.no_header')

        session = RSession()

        def _validateOffset(value):
            try:
                offset = Coord.fromAS(int(value))
            except ValueError:
                offset = Coord.fromDMS(value)

            return offset

        for entry in blockList:

            block_lenght = 0.

            block = entry

            # config = ConfigParser.RawConfigParser()
            #
            # config.read(block[3])

            with open(block[3]) as fp:
                try:
                    config = yaml.load(fp)
                except yaml.YAMLError as exc:
                    self.exit(exc)

            target = session.query(Targets).filter(Targets.id == block[2])
            if target.count() == 0:
                self.exit("No target defined for specified block %i." % block[1])

            addblock = session.query(ObsBlock).filter(ObsBlock.objid == block[2]).filter(
                ObsBlock.blockid == block[1]).filter(ObsBlock.pid == block[0])

            observed = False
            if addblock.count() > 0:
                self.out(red('<<')+'Deleting %i blocks.' % addblock.count())
                for bl in addblock:
                    if bl.observed:
                        self.out(red('!!') + 'Block %i already observed. Leaving as is.' % bl.id)
                        observed = True
                        break
                    for blk_action in bl.actions:
                        # self.out(red('<<')+'Deleting: %s' % blk_action)
                        session.delete(blk_action)
                    session.delete(bl)
                    session.commit()

            if observed:
                continue
            self.out(blue('>>')+'Adding block: %s' % block)
            addblock = ObsBlock(objid=block[2],
                                blockid=block[1],
                                pid=block[0],
                                bparid=block[4])

            # process pre-slew actions
            if 'pre-actions' in config:
                for actconfig in config['pre-actions']:
                    act = actionDict[actconfig['action']]()
                    # self.out('Action: %s' % actconfig['action'])

                    if actconfig['action'] == 'point':
                        if 'ra' in actconfig.keys() and 'dec' in actconfig.keys():
                            epoch = 'J2000' if 'epoch' not in actconfig.keys() else actconfig['epoch']
                            position = Position.fromRaDec(actconfig['ra'], actconfig['dec'], epoch)
                            # self.out('Coords: %s' % position)
                            act.targetRaDec = position
                            # act = Point(targetRaDec=position)
                        elif 'alt' in actconfig.keys() and 'az' in actconfig.keys():
                            position = Position.fromAltAz(actconfig['alt'], actconfig['az'])
                            # self.out('Coords: %s' % position)
                            act.targetAltAz = position
                        elif 'name' in actconfig.keys():
                            # self.out('Target name: %s' % actconfig['name'])
                            act.targetName = actconfig['name']
                        else:
                            act.targetRaDec = Position.fromRaDec(target[0].targetRa, target[0].targetDec, 'J2000')

                    else:
                        for key in actconfig.keys():
                            if hasattr(act, key) and key != 'action':
                                value = actconfig[key]
                                if type(value) == str:
                                    fmt = target[0].__dict__
                                    fmt.update(addblock.__dict__)
                                    value = value.format(**fmt)

                                # self.out('\t%s: %s' % (key, value))
                                try:
                                    setattr(act, key, value)
                                except:
                                    self.err('Could not set attribute %s = %s on action %s' % (key,
                                                                                               actconfig[key],
                                                                                               actconfig['action']))
                    addblock.actions.append(act)

            # Slew to target
            position = Position.fromRaDec(target[0].targetRa, target[0].targetDec, 'J2000')
            slewto = Point()
            slewto.targetRaDec = position
            addblock.actions.append(slewto)
            self.out("Slew to: %s (%s)" % (target[0].name, slewto))

            # process pos-slew actions
            for actconfig in config['pos-actions']:
                act = actionDict[actconfig['action']]()
                # self.out('Action: %s' % actconfig['action'])

                if actconfig['action'] == 'point':
                    if 'ra' in actconfig.keys() and 'dec' in actconfig.keys():
                        epoch = 'J2000' if 'epoch' not in actconfig.keys() else actconfig['epoch']
                        position = Position.fromRaDec(actconfig['ra'], actconfig['dec'], epoch)
                        self.out('Coords: %s' % position)
                        act.targetRaDec = position
                        # act = Point(targetRaDec=position)
                    elif 'alt' in actconfig.keys() and 'az' in actconfig.keys():
                        position = Position.fromAltAz(actconfig['alt'], actconfig['az'])
                        self.out('Coords: %s' % position)
                        act.targetAltAz = position
                    elif 'name' in actconfig:
                        self.out('Target name: %s' % actconfig['name'])
                        act.targetName = actconfig['name']
                    elif 'offset' not in actconfig:
                        self.out('Pointing to target again!')
                        act.targetRaDec = Position.fromRaDec(target[0].targetRa, target[0].targetDec, 'J2000')

                    if 'offset' in actconfig:
                        if 'north' in actconfig['offset']:
                            offset = _validateOffset(actconfig['offset']['north'])
                            self.out('Offset north: %s' % offset)
                            act.offsetNS = offset
                        elif 'south' in actconfig['offset']:
                            offset = _validateOffset(actconfig['offset']['south'])
                            self.out('Offset south: %s' % offset)
                            act.offsetNS = Coord.fromAS(-offset.AS)

                        if 'west' in actconfig['offset']:
                            offset = _validateOffset(actconfig['offset']['west'])
                            self.out('Offset west: %s' % offset)
                            act.offsetEW = offset
                        elif 'east' in actconfig['offset']:
                            offset = _validateOffset(actconfig['offset']['east'])
                            self.out('Offset east: %s' % offset)
                            act.offsetEW = Coord.fromAS(-offset.AS)

                else:
                    for key in actconfig.keys():
                        if hasattr(act, key) and key != 'action':
                            value = actconfig[key]
                            if type(value) == str:
                                fmt = target[0].__dict__
                                fmt.update(addblock.__dict__)
                                value = value.format(**fmt)

                            # self.out('\t%s: %s' % (key, value))
                            try:
                                setattr(act, key, value)
                            except:
                                self.err('Could not set attribute %s = %s on action %s' % (key,
                                                                                           actconfig[key],
                                                                                           actconfig['action']))

                        if act.__tablename__ == 'action_expose':
                            block_lenght += (actconfig['exptime']+12.)*actconfig['frames'] # FIXME: read-out-time hard coded
                        elif act.__tablename__ == 'action_focus' and act.step > 0:
                            block_lenght += 600. # FIXME: focus hard coded

                addblock.actions.append(act)

            addblock.length = block_lenght
            session.add(addblock)

            session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="cleanObservingBlock",
            help='Delete all observing blocks from the database.',
            helpGroup="OB", actionGroup="OB")
    def cleanObservingBlock(self, opt):

        # save a copy
        if os.path.exists(DEFAULT_PROGRAM_DATABASE):
            shutil.copy(DEFAULT_PROGRAM_DATABASE,
                        "%s.%s.bak" % (DEFAULT_PROGRAM_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        session = RSession()

        nblocks = int(session.query(ObsBlock).count())

        if nblocks == 0:
            self.out('-Observing block list is alredy empty')
            session.commit()
            self.out('-Done')
            return 0

        self.out('-Deleting all %i observing blocks from database' % (nblocks))

        blockList = session.query(ObsBlock).all()

        for block in blockList:
            for blk_action in block.actions:
                session.delete(blk_action)
            session.delete(block)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="deleteObservingBlock",
            help='Delete observing blocks of a specific project (PID) from the database.',
            helpGroup="OB", actionGroup="OB")
    def deleteObservingBlock(self, opt):

        if not opt.pid:
            self.err(red('*') + 'Specify project to delete with \'--pid\' ...')
            return -1

        # save a copy
        if os.path.exists(DEFAULT_ROBOBS_DATABASE):
            shutil.copy(DEFAULT_ROBOBS_DATABASE,
                        "%s.%s.bak" % (DEFAULT_ROBOBS_DATABASE,
                                       time.strftime("%Y%m%d%H%M%S")))

        session = RSession()

        nblocks = int(session.query(ObsBlock).filter(ObsBlock.pid == opt.pid).count())

        if nblocks == 0:
            self.out('-No observing block with PID=%s to delete' % opt.pid)
            session.commit()
            self.out('-Done')
            return 0

        self.out('-Deleting all %i observing blocks with PID=%s from database' % (nblocks, opt.pid))

        blockList = session.query(ObsBlock).filter(ObsBlock.pid == opt.pid).all()

        for block in blockList:
            for blk_action in block.actions:
                session.delete(blk_action)
            session.delete(block)

        session.commit()

        self.out('-Done')

        return 0

    ############################################################################

    @action(long="showObservingLog",
            help="Show entries on Observing Log database. User can specify start/end dates, only start or end works as well.",
            actionGroup="")
    def showObservingLog(self,opt):

        session = RSession()

        self.mktimes(opt)

        query = session.query(ObservingLog).filter(ObservingLog.time > self.obsStart-dt.timedelta(hours=2),
                                                   ObservingLog.time <= self.obsEnd).order_by(ObservingLog.time+dt.timedelta(hours=2))

        for q in query:
            self.out('%s'%q)

    ############################################################################

    @action(long="makeObservingLog",
            help="Process entries on Observing Log database and generate charts and graphs with observing information. User can specify start/end dates, only start or end works as well.",
            actionGroup="")
    def makeObservingLog(self,opt):
        import matplotlib
        matplotlib.use('Agg')
        import matplotlib.pyplot as py
        # matplotlib.use('macosx')
        # import pylab as py
        # import plotly.plotly as py
        # from plotly.graph_objs import Data,Scatter,Layout,Figure,YAxis,Line

        session = RSession()

        self.mktimes(opt)

        query = session.query(ObservingLog).filter(ObservingLog.time > self.obsStart-dt.timedelta(hours=2),
                                                   ObservingLog.time <= self.obsEnd+dt.timedelta(hours=2))

        tid = np.array([],dtype=np.int)

        for q in query:
            tid = np.append(tid,q.tid)
            #self.out('%s'%q)

        color_config = None
        if opt.filename is not None:
            try:
                with open(opt.filename, 'r') as fp:
                    color_config = yaml.load(fp)
            except IOError, e:
                self.err('Could not find pid-color code file. Using same color for all projects.')
        tid = np.unique(tid)

        # site = self.site()
        trace = []

        alt_min= 30
        alt_max= 90

        # print self.obsStart, self.site.LST_inRads(self.obsStart)
        py.plot([self.obsStart,self.obsStart],
                [alt_min,alt_max],'r--')
        py.plot([self.obsEnd,self.obsEnd],
                [alt_min,alt_max],'r--')
        py.plot([self.obsStart-dt.timedelta(hours=2),self.obsEnd+dt.timedelta(hours=2)],
                [alt_min+10,alt_min+10],'r--')

        for id in tid:
            target = session.query(Targets).filter(Targets.id == id).first()
            if target is None:
                continue
            time,alt = self.altitude(ra = target.targetRa,
                                     dec = target.targetDec,
                                     start = self.obsStart-dt.timedelta(hours=5),
                                     end = self.obsEnd+dt.timedelta(hours=2),
                                     tdelta=1./30.)

            py.plot(time,alt,'b-')
            # trace.append(Scatter(x = time,
            #                      y = alt, #np.exp(1.-1./secz)
            #                      mode='lines',
            #                      line=Line(
            #                             color='red',
            #                             width=0.5
            #                             )
            #                      )
            #              )

            targetObs = query.filter(ObservingLog.tid == id)
            program = session.query(Program).filter(Program.priority == targetObs[0].priority).first()

            start = []
            end = []
            if opt.simulation:
                obs_start = 'Acquisition Start'
                obs_end = 'Acquisition End'
            else:
                obs_start = 'Program Started'
                obs_end = 'Program End'

            for obs in targetObs:

                if obs_start in obs.action:
                    start.append(obs.time)
                elif obs_end in obs.action:
                    end.append(obs.time)
            if len(start) != len(end):
                self.err('Start/end of observations of target does not match')
                continue

            ylim = py.ylim()
            for i in range(len(start)):
                time,alt = self.altitude(ra = target.targetRa,
                                         dec = target.targetDec,
                                         start = start[i],
                                         end = end[i],
                                         tdelta=1./60.)

                color = 'green'
                alpha = 0.5
                if color_config is not None and program.pid in color_config:
                    color = color_config[program.pid]['color']
                    alpha = color_config[program.pid]['alpha']

                py.fill_between(time,alt,ylim[0],facecolor=color, alpha=alpha)
                # trace.append(Scatter(x = time,
                #                      y = alt, #np.exp(1.-1./secz)
                #                      mode='lines',
                #                      line=Line(
                #                             color=color[int(targetObs[i].priority)],
                #                             width=1.0
                #                             ),
                #                      fill='tozeroy',
                #                      name=target.name
                #                      )
                #              )
            py.ylim(ylim)

        # print xlim
        # py.xlim(xlim)
        py.xlim(self.obsStart-dt.timedelta(hours=2),self.obsEnd+dt.timedelta(hours=2))
        py.ylim(alt_min,alt_max)
        py.xticks(rotation=70)

        # py.show()
        py.gcf().axes[0].xaxis.set_major_formatter(DateFormatter('%H:%M'))
        py.title("Observation plan as of %s" % dt.datetime.utcnow().isoformat().split('.')[0])
        py.grid()
        py.ylabel("Altitude (deg)")
        py.savefig('foo.png')
        # data = Data(trace)
        # layout = Layout(yaxis=YAxis(autorange='reversed'))
        # fig = Figure(data=data)#, layout=layout)
        # plot_url = py.plot(fig, filename='airmass')

    ############################################################################

    @action(long="cleanObservingLog",
            help="Delete entries on Observing Log database. If no date is specified swipe clean the log database. User can specify start/end dates, only start or end works as well.",
            actionGroup="")
    def cleanObservingLog(self,opt):

        session = RSession()

        self.mktimes(opt)
        # Query all obs logs entries

        query = session.query(ObservingLog).filter(ObservingLog.time > self.obsStart-dt.timedelta(hours=2),
                                                   ObservingLog.time <= self.obsEnd+dt.timedelta(hours=2))

        for q in query:
            session.delete(q)
            session.commit()

    @action(long="cleanQueue",
            help="Delete all scheduled blocks from specified project.",
            actionGroup="")
    def cleanQueue(self,opt):

        session = RSession()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(Projects).filter(Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        self.out('-Deleting all scheduled observing blocks from project %s from the queue.'%opt.PID)

        programs = session.query(Program).filter(Program.pid == opt.PID)

        for p in programs:
            self.out(red('--Deleting'))
            self.out( red('---')+'%s'%p )
            # for act in p.actions:
            #     session.delete(act)
            #     self.out( red('---')+'%s'%act)
            session.delete(p)
            self.out(red('--Done'))

        session.commit()

        sched_blocks = session.query(ObsBlock).filter(ObsBlock.pid == opt.PID,
                                                      ObsBlock.scheduled == 1)

        for sb in sched_blocks:
            sb.scheduled = 0

        for sched in schedAlgorithms:
            schedAlgorithms[sched].clean(opt.PID)


        session.commit()

        return 0

    ############################################################################

    @action(long="makeQueue",
            help="Select targets from specified project to be observed. ",
            actionGroup="")
    def makeQueue(self,opt):

        session = RSession()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(Projects).filter(Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        if self.checkQueue(opt.PID):
            self.out(red('+')+'Project already processed... Reprocessing a queue is a nasty job... Clean it and try again...')
            session.commit()
            return 0

        pgrconfig = {}
        if opt.PIDCONFIG is not None:
            with open(opt.PIDCONFIG, 'r') as stream:
                try:
                    pgrconfig = yaml.load(stream)
                except yaml.YAMLError as exc:
                    self.exit(exc)


        self.out('-Selecting targets from project %s'%opt.PID)

        self.mktimes(opt)

        obsStart = self.obsStart
        obsEnd = self.obsEnd
        lststart = opt.LSTstart if opt.LSTstart is not None else self.lststart-2.
        lstend = opt.LSTend if opt.LSTend is not None else self.lstend+2.
        remoteManager = self.robobs.getManager()
        site = remoteManager.getProxy(remoteManager.getResourcesByClass("Site")[0])

        self.out('-Observation start @ %s | LST = %4.1f h'%(str(obsStart)[:19],lststart))
        self.out('-Observation end   @ %s | LST = %4.1f h'%(str(obsEnd)[:19],lstend))

        obsStart = site.JD(obsStart)
        obsEnd = site.JD(obsEnd)

        ohh = int(np.floor( (obsEnd-obsStart)*24. ))
        omm = int( np.floor( ((obsEnd-obsStart)*24. - ohh) * 60. ))
        self.out('-Observing time: %02i:%02i h'%(ohh,omm))

        # Look for suitable observing blocks for this night...
        FLAG = opt.PID

        ## Select all observing blocks from this project that where not observed
        ## and are not scheduled for observations

        targets = session.query(Targets)
        for target in targets:
            target.lst = self.lststart.H
            # self.out('%s %.2f %.2f' % (target,target.targetRa,target.targetAH))
        session.commit()
        # targets = session.query(Targets).order_by(Targets.targetAH)
        # for target in targets:
        #     self.out('%s %.2f %.2f' % (target,target.targetRa,target.targetAH))

        tList = None
        if lststart < lstend:
            tList = session.query(ObsBlock,BlockPar,Targets).filter(ObsBlock.pid == FLAG,
                                                                    BlockPar.pid == FLAG,
                                                                    ObsBlock.scheduled == False,
                                                                    ObsBlock.completed == False,
                                                                    Targets.targetRa > lststart,
                                                                    Targets.targetRa < lstend).join(BlockPar).join(
                Targets).order_by(desc(Targets.targetAH))
        else:
            tList = session.query(ObsBlock, BlockPar, Targets).filter(ObsBlock.pid == FLAG,
                                                                      BlockPar.pid == FLAG,
                                                                      ObsBlock.scheduled == False,
                                                                      ObsBlock.completed == False,
                                                                      or_(and_(Targets.targetRa > lststart,
                                                                               Targets.targetRa < 24.),
                                                                          and_(Targets.targetRa > 0.,
                                                                               Targets.targetRa < lstend))).join(
                Targets).order_by(desc(Targets.targetAH))

        if len(tList[:]) == 0:
            self.out(blue('+') + 'No targets available from this project this night...')
            session.commit()
            return -1

        self.out('-Found %i suitable targets...'%(len(tList[:])))
        for target in tList:
            self.out(" - %s" % target[2])

        schedAlgList = np.array([t[1].schedalgorith for t in tList])
        uSAL = np.unique(schedAlgList)

        self.out('-Found %i types of scheduling algorith...'%(len(uSAL)))
        for i,sa_type in enumerate(uSAL):
            self.out('--SA Type[%i] = %i'%(i+1,sa_type))

        for sAL in uSAL:

            nquery = tList.filter(BlockPar.schedalgorith == sAL)

            sched = schedAlgorithms[sAL]

            # qFunction = algorithms.ScheduleFunction(sAL,
            #                                         obsStart=obsStart,
            #                                         obsEnd=obsEnd,
            #                                         s=self,
            #                                         query=nquery,
            #                                         site=site)

            obsTargets = sched.process(self.bestSlotLen(opt.PID),
                                       obsStart=obsStart,
                                       obsEnd=obsEnd,
                                       query=nquery,
                                       site=site,
                                       config=pgrconfig)

            # First schedule all
            for bid in obsTargets:
                if bid['blockid'] > 0:
                    oblock = nquery.filter(ObsBlock.blockid == bid['blockid'])
                    self.addObservation(oblock,bid['start'])

            # Now mark as scheduled
            for bid in obsTargets:
                if bid['blockid'] > 0:
                    oblock = nquery.filter(ObsBlock.blockid == bid['blockid'])
                    for o in oblock:
                        o[0].scheduled = True
                    session.commit()

        session.commit()

    ############################################################################

    @action(help="Start manager", helpGroup="RUN", actionGroup="RUN")
    def start(self, options):

        robobs = self.robobs
        self.out('Starting robobs... ',end='')

        if robobs.start():
            self.out(green('OK'))
        else:
            self.out(red("FAILED"))

        return 0

    ############################################################################
    @action(help="Start scheduler", helpGroup="RUN", actionGroup="RUN")
    def wake(self, options):

        robobs = self.robobs

        robobs.wake()

        return 0

    ############################################################################

    @action(help="Stop manager", helpGroup="RUN", actionGroup="RUN")
    def stop(self, options):

        robobs = self.robobs

        self.out('Stopping robobs... ',end='')
        if robobs.stop():
            self.out(green('OK'))
        else:
            self.out(red('FAILED'))

        return 0

    ############################################################################

    @action(help="Monitor manager", helpGroup="RUN", actionGroup="RUN")
    def monitor(self, options):

        return 0

    ############################################################################

    @action(long="processQueue",
            help="Process queue like chimera will do during an observation.",
            actionGroup="")
    def processQueue(self,opt):

        self.mktimes(opt)

        site = self.site
        telescope = self.telescope
        obsStart = site.JD(self.obsStart)-2400000.5
        obsEnd = site.JD(self.obsEnd)-2400000.5
        lststart = self.lststart
        lstend = self.lstend


        otime = obsStart

        appOpen = 0.
        idle = 0.

        # qExec = queue.QueueScheduler(site)

        session = RSession()
        telPos = None #current telescope position

        while otime < obsEnd:
            #aP,aplen = self.getAlternateProgram(aprograms,time)
            #if aplen < 0:
            #    break
            self.out('Requesting target @ %f'%otime, end='')
            program_list = self.robobs.reshedule(otime)
            if not program_list:
                break
            program = session.merge(program_list[0])
            obs_block = session.merge(program_list[2])
            self.out('slew@: %s' % program.slewAt)

            program = session.merge(program)
            aplen = obs_block.length

            #while 0 <  aplen/86.4e3 < idleTime:
            msg = ''
            slewAt = float(program.slewAt)
            _idle = slewAt - otime
            # if _idle*24.*60.*60. < aplen:
            #     slewAt = otime
            #     _idle = 0.
            # print slewAt,otime
            stime = otime
            if _idle > 1e-5:
                msg += '[info: Program slew %.3fm in the future. waiting...]'%( (_idle)*24.*60. )
                idle += _idle
                stime+=_idle
            elif _idle < -1e-5:
                msg += '[info: Program slew %.3fm in the past. Slewing now...]'%  ( (_idle)*24.*60. )

            _idle = _idle if _idle > 0 else 0.
            slewtime = 0.
            target = session.query(Targets).filter(Targets.id == program.tid).first()
            # check that target is at correct altitude.

            targetPos = Position.fromRaDec(target.targetRa,target.targetDec)
            if telPos:
                adist = telPos.angsep(targetPos)
                slewtime = np.float(adist.toAS())/60./60./86.4e3 # consider 1 arcmin / second
            slewtime = slewtime if slewtime > _idle else 0 # if slewtime larger than idle time slewtime will be zero
            msg += ' | slewtime = %.5fm'%(slewtime*60.*60.)
            self.out('@ %.5f (%.5f): Acquiring %45s %s (len: %.2f)'%(otime,slewAt,program,msg, aplen))
            log = ObservingLog(time=datetimeFromJD(stime+2400000.5,),
                                 tid=program.tid,
                                 name=program.name,
                                 priority=program.priority,
                                 action='Simulation: Acquisition Start')
            session.add(log)
            session.commit()

            log = ObservingLog(time=datetimeFromJD(stime+(aplen/86.4e3)+2400000.5,),
                         tid=program.tid,
                         name=program.name,
                         priority=program.priority,
                         action='Simulation: Acquisition End')
            session.add(log)

            dt = (aplen/86.4e3) + slewtime + _idle
            otime+=dt

            appOpen+=aplen
            program.finished = True
            session.commit()

            blockpar= session.merge(program_list[1])
            self.out('%s: %i %s' % (blockpar,blockpar.schedalgorith,schedAlgorithms[blockpar.schedalgorith].name()))
            remoteManager = self.robobs.getManager()

            schedAlgorithms[blockpar.schedalgorith].observed(otime,program_list,
                                                             site = remoteManager.getProxy(
                                                                 remoteManager.getResourcesByClass("Site")[0]),
                                                             soft = True)
            telPos = targetPos
            session.commit()

        aprograms = session.query(Program).filter(Program.finished == True)

        for ap in aprograms:
            ap.finished = False

        allpid = [ p.pid for p in session.query(Projects)]

        session.commit()
        for sched in schedAlgorithms:
            for pid in allpid:
                schedAlgorithms[sched].soft_clean(pid)

        session.commit()

        self.out('@ %.4f: Idle for %.2fh'%(otime,(obsEnd-otime)*24.))
        idle += (obsEnd-otime)
        self.out('@ %.4f: Night end'%obsEnd)
        self.out('-Total idle time: %.2fh'%(idle*24.))
        self.out('-Total open shutter time: %.2fh'%(appOpen/60./60.))

    ############################################################################

    def mktimes(self,opt):
        # Determining start/end times

        remoteManager = self.robobs.getManager()
        site = remoteManager.getProxy(remoteManager.getResourcesByClass("Site")[0])

        self.obsStart = site.sunset_twilight_end()
        self.obsEnd = site.sunrise_twilight_begin(self.obsStart)

        if opt.JDstart:
            self.obsStart = datetimeFromJD(opt.JDstart)
        elif opt.dstart:
            day,hour = opt.dstart.split('-')
            yy,mm,dd = [int(val) for val in day.split('/')]
            hh,mi,ss = [int(val) for val in hour.split(':') ]
            self.obsStart = dt.datetime(yy,mm,dd,hh,mi,ss)

        if opt.JDend:
            self.obsEnd = datetimeFromJD(opt.JDend)
        elif opt.dend:
            day,hour = opt.dend.split('-')
            yy,mm,dd = [int(val) for val in day.split('/')]
            hh,mi,ss = [int(val) for val in hour.split(':') ]
            self.obsEnd = dt.datetime(yy,mm,dd,hh,mi,ss)

        if opt.yesterday:
            self.obsStart -= dt.timedelta(days=1)
            self.obsEnd -= dt.timedelta(days=1)

        self.lststart = site.LST(self.obsStart).toH()
        self.lstend = site.LST(self.obsEnd).toH()
        self.lststart_deg = site.LST(self.obsStart).toD()
        self.lstend_deg = site.LST(self.obsEnd).toD()
        self.mjdStart = site.MJD(self.obsStart)
        self.mjdEnd =  site.MJD(self.obsEnd)

    ############################################################################

    def calcObsTime(self,program,rot=0.):
        otime = 0.

        session = RSession()
        obs_block = session.query(ObsBlock).filter(ObsBlock.id == program.obsblock_id).first()
        for ii,act in enumerate(obs_block.actions):
            if act.__tablename__ == 'action_expose':
                otime+=(act.exptime+rot)*act.frames
            elif act.__tablename__ == 'action_focus' and act.step > 0:
                otime += 600.
        return otime

    ############################################################################

    def checkQueue(self, PID):
        '''Check if projet was already processed...
            '''

        session = RSession()

        progs = session.query(Program).filter(Program.pid == PID).first()

        if progs is not None:
            session.commit()
            return True

        session.commit()
        return False

    ############################################################################

    def bestSlotLen(self,pid):

        # FIXME

        # session = RSession()
        #
        # query = session.query(ObsBlock).filter(ObsBlock.pid == pid).filter(ObsBlock.blockid == blkid)
        #
        # # slen = 0
        #
        # tottime = 0.
        #
        # bid = -1
        # for blk in query:
        #     for blk_action in blk.actions:
        #         # Todo: Add overheads: Pointing, autofocus, readout, filter,...
        #         if blk_action.__tablename__ == 'action_expose':
        #             tottime += blk_action.exptime * blk_action.frames
        # session.commit()

        return 15.

    ############################################################################

    def addObservation(self,block,obstime):

        session = RSession()

        self.out('%s '%block[:][0][0])

        programs = []

        for subblock in block:

            objname = subblock[2].name
            pquery = session.query(Projects).filter(Projects.pid == subblock[0].pid)
            self.out('\t @%.3f - %s' % (obstime-2400000.5, subblock[2]))
            program = Program(tid=subblock[0].objid,
                              name = objname,
                              pi='',
                              priority=pquery[0].priority,
                              slewAt=obstime-2400000.5,
                              pid=subblock[0].pid,
                              obsblock_id=subblock[0].id,
                              blockpar_id=subblock[1].id
                              )#,exposeAt=obstime)
            # for blk_actions in subblock[0].actions:
            #     program.actions.append(blk_actions)

            programs.append(program)

            sched_add = schedAlgorithms[subblock[1].schedalgorith]
            sched_add.add(subblock)

        session.add_all(programs)
        session.commit()

        # algorith specific process


    def altitude(self,ra,dec,start,end,tdelta=0.5,minA=10.):

        site = self.site

        coords = Position.fromRaDec(ra,
                                 dec)

        timevec = np.array([])
        amvec = np.array([])

        time = start
        while time < end:
        #for time in range(start,end,dt.timedelta(hours=tdelta)):
            #print type(time)
            lst = site.LST_inRads(time)
            alt = float(site.raDecToAltAz(coords,lst).alt)
            # airmass = 1./np.cos(np.pi/2.-alt*np.pi/180.)
            if minA < alt <= 90.:
                timevec = np.append(timevec,time)
                amvec = np.append(amvec,alt)
            time += dt.timedelta(hours=tdelta)

        return timevec,amvec

################################################################################

def main():
    cli = RobObs()
    cli.run(sys.argv)
    cli.wait()

################################################################################

if __name__ == '__main__':

    main()

################################################################################
